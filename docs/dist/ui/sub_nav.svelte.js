import './sub_nav.svelte.css.proxy.js';
/* src/ui/sub_nav.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	space,
	svg_element,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import interact from "../../_snowpack/pkg/interactjs.js";
import { onMount } from "../../_snowpack/pkg/svelte.js";
import SVGWipe from "../components/SVGWipe.svelte.js";
import { getCSSCustomProp } from "../utils/helpers.js";
import { DIM, subNavExpanded } from "../stores.js";
import CharList from "./sub_nav.char.svelte.js";
import BGList from "./sub_nav.bg.svelte.js";
import Call from "./sub_nav.call.svelte.js";
import StickerList from "./sub_nav.sticker.svelte.js";
import Settings from "./sub_nav.settings.svelte.js";
import Expressions from "./sub_nav.exp.svelte.js";
import { userExps } from "../scene/character.svelte.js";
import FTUE, { updateFtue } from "./ftue.svelte.js";

function create_default_slot(ctx) {
	let style;
	let t1;
	let path;

	return {
		c() {
			style = element("style");
			style.textContent = "svg{\n        pointer-events:none;\n      }";
			t1 = space();
			path = svg_element("path");
			attr(path, "class", "shape-overlays__path");
			attr(path, "fill", /*theme*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, style, anchor);
			insert(target, t1, anchor);
			insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*theme*/ 8) {
				attr(path, "fill", /*theme*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(style);
			if (detaching) detach(t1);
			if (detaching) detach(path);
		}
	};
}

// (230:4) {:else}
function create_else_block(ctx) {
	return {
		c: noop,
		m: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (228:64) 
function create_if_block_5(ctx) {
	let expressions;
	let current;
	expressions = new Expressions({});

	return {
		c() {
			create_component(expressions.$$.fragment);
		},
		m(target, anchor) {
			mount_component(expressions, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(expressions.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(expressions.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(expressions, detaching);
		}
	};
}

// (226:38) 
function create_if_block_4(ctx) {
	let settings;
	let current;
	settings = new Settings({});

	return {
		c() {
			create_component(settings.$$.fragment);
		},
		m(target, anchor) {
			mount_component(settings, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(settings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(settings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(settings, detaching);
		}
	};
}

// (224:33) 
function create_if_block_3(ctx) {
	let call;
	let current;
	call = new Call({});

	return {
		c() {
			create_component(call.$$.fragment);
		},
		m(target, anchor) {
			mount_component(call, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(call.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(call.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(call, detaching);
		}
	};
}

// (222:36) 
function create_if_block_2(ctx) {
	let stickerlist;
	let current;
	stickerlist = new StickerList({});

	return {
		c() {
			create_component(stickerlist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stickerlist, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(stickerlist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stickerlist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stickerlist, detaching);
		}
	};
}

// (220:31) 
function create_if_block_1(ctx) {
	let bglist;
	let current;
	bglist = new BGList({});

	return {
		c() {
			create_component(bglist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(bglist, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(bglist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(bglist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(bglist, detaching);
		}
	};
}

// (218:3) {#if selected === 'char'}
function create_if_block(ctx) {
	let charlist;
	let current;
	charlist = new CharList({});

	return {
		c() {
			create_component(charlist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(charlist, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(charlist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(charlist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(charlist, detaching);
		}
	};
}

function create_fragment(ctx) {
	let container;
	let button;
	let t3;
	let div0;
	let t4;
	let section;
	let svgwipe;
	let t5;
	let div1;
	let current_block_type_index;
	let if_block;
	let container_class_value;
	let t6;
	let ftue;
	let current;
	let mounted;
	let dispose;

	let svgwipe_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	svgwipe = new SVGWipe({ props: svgwipe_props });
	/*svgwipe_binding*/ ctx[8](svgwipe);

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*selected*/ ctx[0] === "char") return 0;
		if (/*selected*/ ctx[0] === "bg") return 1;
		if (/*selected*/ ctx[0] === "sticker") return 2;
		if (/*selected*/ ctx[0] === "call") return 3;
		if (/*selected*/ ctx[0] === "settings") return 4;
		if (/*selected*/ ctx[0] === "exp" && /*$userExps*/ ctx[5].list.length > 0) return 5;
		return 6;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	ftue = new FTUE({
			props: {
				selected: /*selected*/ ctx[0],
				style: /*customVars*/ ctx[4]
			}
		});

	return {
		c() {
			container = element("container");
			button = element("button");

			button.innerHTML = `<i class="kalicon notranslate fill small svelte-buekxu">jellyfill</i> 
    <i class="kalicon notranslate solid small">close</i>`;

			t3 = space();
			div0 = element("div");
			t4 = space();
			section = element("section");
			create_component(svgwipe.$$.fragment);
			t5 = space();
			div1 = element("div");
			if_block.c();
			t6 = space();
			create_component(ftue.$$.fragment);
			attr(button, "class", "subnav-close svelte-buekxu");
			attr(div0, "class", "nav-touch no_highlights svelte-buekxu");
			attr(section, "class", "svelte-buekxu");
			attr(div1, "class", "content svelte-buekxu");
			attr(container, "class", container_class_value = "subnav " + (!/*selected*/ ctx[0] ? "hide" : "") + " " + (/*sideSelected*/ ctx[1] ? "dim" : "") + " svelte-buekxu");
			attr(container, "style", /*customVars*/ ctx[4]);
			attr(container, "data-dragging", "false");
			attr(container, "data-status", "waitiing");
		},
		m(target, anchor) {
			insert(target, container, anchor);
			append(container, button);
			append(container, t3);
			append(container, div0);
			append(container, t4);
			append(container, section);
			mount_component(svgwipe, section, null);
			append(container, t5);
			append(container, div1);
			if_blocks[current_block_type_index].m(div1, null);
			/*container_binding*/ ctx[9](container);
			insert(target, t6, anchor);
			mount_component(ftue, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*close*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const svgwipe_changes = {};

			if (dirty & /*$$scope, theme*/ 524296) {
				svgwipe_changes.$$scope = { dirty, ctx };
			}

			svgwipe.$set(svgwipe_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}

			if (!current || dirty & /*selected, sideSelected*/ 3 && container_class_value !== (container_class_value = "subnav " + (!/*selected*/ ctx[0] ? "hide" : "") + " " + (/*sideSelected*/ ctx[1] ? "dim" : "") + " svelte-buekxu")) {
				attr(container, "class", container_class_value);
			}

			if (!current || dirty & /*customVars*/ 16) {
				attr(container, "style", /*customVars*/ ctx[4]);
			}

			const ftue_changes = {};
			if (dirty & /*selected*/ 1) ftue_changes.selected = /*selected*/ ctx[0];
			if (dirty & /*customVars*/ 16) ftue_changes.style = /*customVars*/ ctx[4];
			ftue.$set(ftue_changes);
		},
		i(local) {
			if (current) return;
			transition_in(svgwipe.$$.fragment, local);
			transition_in(if_block);
			transition_in(ftue.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(svgwipe.$$.fragment, local);
			transition_out(if_block);
			transition_out(ftue.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(container);
			/*svgwipe_binding*/ ctx[8](null);
			destroy_component(svgwipe);
			if_blocks[current_block_type_index].d();
			/*container_binding*/ ctx[9](null);
			if (detaching) detach(t6);
			destroy_component(ftue, detaching);
			mounted = false;
			dispose();
		}
	};
}

let wipeComponent = null;
const interactThreshold = 100;

function instance($$self, $$props, $$invalidate) {
	let $DIM;
	let $userExps;
	component_subscribe($$self, DIM, $$value => $$invalidate(13, $DIM = $$value));
	component_subscribe($$self, userExps, $$value => $$invalidate(5, $userExps = $$value));
	let { selected = null } = $$props;
	let { sideSelected = null } = $$props;
	let { forceClose = false } = $$props;
	let subnav;
	let theme = "var(--iconbg)";
	let customVars = "";
	let maxY = 300;
	let x = 0, y = 0;

	const openClose = () => {
		if (wipeComponent.isOpen) {
			if (!selected || selected === "close") {
				close();
			}
		} else if (!wipeComponent.isOpen) {
			open();
		}
	};

	const close = () => {
		updateFtue(selected);
		let isMobile = $DIM.w < 600;

		wipeComponent.animate({
			action: "close",
			axis: isMobile ? "y" : "x",
			_flip: isMobile ? false : true,
			_curve: "curve",
			_numPoints: 5,
			_duration: isMobile ? 0 : 600
		});

		$$invalidate(0, selected = null);
		$$invalidate(7, forceClose = false);
	};

	const open = () => {
		let isMobile = $DIM.w < 600;

		wipeComponent.animate({
			action: "open",
			axis: isMobile ? "y" : "x",
			_curve: "cuve",
			_flip: isMobile ? true : false,
			_numPoints: 5,
			_duration: 600
		});

		$$invalidate(7, forceClose = false);
	};

	function dragMoveListener(event) {
		event.preventDefault();

		// keep the dragged position in the custom properties
		x = (getCSSCustomProp("--container-x", subnav, "float") || 0) + event.dx;

		y = (getCSSCustomProp("--container-y", subnav, "float") || 0) + event.dy;
		if (x > 0) x = 0;
		if (y < 0) y = 0;

		// update styles
		subnav.setAttribute("data-status", "");

		subnav.style.setProperty("--container-x", x + "px");
		subnav.style.setProperty("--container-y", y + "px");
	}

	function transitionListener(e) {
		if (e.propertyName === "transform") {
			subnav.setAttribute("data-status", "waiting");
			subnav.removeEventListener("transitionend", transitionListener);
			subnav.style.setProperty("--container-x", "0px");
			subnav.style.setProperty("--container-y", "0px");
			close();
		}
	}

	const closeMobile = () => {
		y = maxY;
		subnav.setAttribute("data-status", "transition");

		// mark as done after CSS transition
		subnav.addEventListener("transitionend", transitionListener);

		subnav.style.setProperty("--container-y", y + "px");
		$$invalidate(7, forceClose = false);
	};

	onMount(() => {
		interact(".subnav[data-dragging=\"false\"] .nav-touch").on("tap", closeMobile);

		interact(".subnav[data-dragging=\"false\"] .nav-touch").draggable({
			onstart: () => {
				// signify dragging
				subnav.setAttribute("data-dragging", true);
			},
			onmove: dragMoveListener,
			onend: event => {
				subnav.setAttribute("data-dragging", false);

				// calculate how far card moved
				let moved = Math.sqrt(Math.pow(event.pageX - event.x0, 2) + Math.pow(event.pageY - event.y0, 2) | 0);

				if (moved > interactThreshold) {
					y = maxY;
					subnav.setAttribute("data-status", "transition");

					// mark as done after CSS transition
					subnav.addEventListener("transitionend", transitionListener);
				} else {
					// reset vars
					x = 0;

					y = 0;
				}

				// update x and y pos
				subnav.style.setProperty("--container-x", x + "px");

				subnav.style.setProperty("--container-y", y + "px");
			}
		});
	});

	function svgwipe_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			wipeComponent = $$value;
			wipeComponent
		});
	}

	function container_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			subnav = $$value;
			$$invalidate(2, subnav);
		});
	}

	$$self.$$set = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("sideSelected" in $$props) $$invalidate(1, sideSelected = $$props.sideSelected);
		if ("forceClose" in $$props) $$invalidate(7, forceClose = $$props.forceClose);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selected*/ 1) {
			$: {
				subNavExpanded.set(selected);
			}
		}

		if ($$self.$$.dirty & /*selected*/ 1) {
			$: {
				if (selected && wipeComponent) {
					openClose();
				}
			}
		}

		if ($$self.$$.dirty & /*forceClose*/ 128) {
			$: {
				if (forceClose) {
					closeMobile();
				}
			}
		}

		if ($$self.$$.dirty & /*selected*/ 1) {
			$: {
				switch (selected) {
					case "char":
						$$invalidate(3, theme = "var(--darkgrey)");
						$$invalidate(4, customVars = "");
						maxY = 210;
						break;
					case "call":
						$$invalidate(3, theme = "var(--darkgrey)");
						$$invalidate(4, customVars = "--container-w-d:360px;--container-h-m:360px;");
						maxY = 360;
						break;
					case "bg":
						$$invalidate(3, theme = "var(--darkgrey)");
						$$invalidate(4, customVars = "");
						maxY = 210;
						break;
					case "sticker":
						$$invalidate(3, theme = "var(--darkgrey)");
						$$invalidate(4, customVars = "");
						maxY = 210;
						break;
					case "exp":
						$$invalidate(4, customVars = "--container-w-d:100px;");
						$$invalidate(3, theme = "var(--darkgrey)");
						maxY = 210;
						break;
					case "settings":
						$$invalidate(3, theme = "var(--darkgrey)");
						$$invalidate(4, customVars = "--container-w-d:360px;--container-h-m:290px;");
						maxY = 290;
						break;
					default:
				}
			}
		}
	};

	return [
		selected,
		sideSelected,
		subnav,
		theme,
		customVars,
		$userExps,
		close,
		forceClose,
		svgwipe_binding,
		container_binding
	];
}

class Sub_nav extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			selected: 0,
			sideSelected: 1,
			forceClose: 7
		});
	}
}

export default Sub_nav;
export { wipeComponent };