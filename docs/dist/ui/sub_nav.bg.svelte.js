import './sub_nav.bg.svelte.css.proxy.js';
/* src/ui/sub_nav.bg.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	add_transform,
	append,
	attr,
	check_outros,
	component_subscribe,
	create_animation,
	create_in_transition,
	create_out_transition,
	detach,
	element,
	fix_and_outro_and_destroy_block,
	fix_position,
	group_outros,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_store_value,
	set_style,
	space,
	subscribe,
	svg_element,
	toggle_class,
	transition_in,
	transition_out,
	update_keyed_each
} from "../../_snowpack/pkg/svelte/internal.js";

import { notifText } from "./notif.svelte.js";
import { isImageVideo } from "../utils/helpers.js";

import {
	DIM,
	urlBase,
	breakpoint,
	getLocalStorage,
	subLocalStorage,
	setLang
} from "../stores.js";

import { bgURL, bgList } from "../scene/pixi.bg.svelte.js";
import { writable, get } from "../../_snowpack/pkg/svelte/store.js";
import iro from "../../_snowpack/pkg/@jaames/iro.js";
import { fade, fly, scale } from "../../_snowpack/pkg/svelte/transition.js";
import { flip } from "../../_snowpack/pkg/svelte/animate.js";
import { cubicInOut } from "../../_snowpack/pkg/svelte/easing.js";
import { ftueState, updateFtue } from "./ftue.svelte.js";
import { onMount } from "../../_snowpack/pkg/svelte.js";
import { dropzone } from "./filedrop.svelte.js";
import { subnav_bg_text } from "../text/translations.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (130:46) 
function create_if_block_3(ctx) {
	let div;
	let mounted;
	let dispose;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[12](/*bg*/ ctx[15], ...args);
	}

	return {
		c() {
			div = element("div");
			attr(div, "class", "content color svelte-1f9j6x");
			set_style(div, "--bgUrl", /*bg*/ ctx[15].url);
			toggle_class(div, "transparent", /*bg*/ ctx[15].url.length > 7);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$bgList*/ 1) {
				set_style(div, "--bgUrl", /*bg*/ ctx[15].url);
			}

			if (dirty & /*$bgList*/ 1) {
				toggle_class(div, "transparent", /*bg*/ ctx[15].url.length > 7);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (128:43) 
function create_if_block_2(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;
	let mounted;
	let dispose;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[11](/*bg*/ ctx[15], ...args);
	}

	return {
		c() {
			img = element("img");
			attr(img, "class", "content svelte-1f9j6x");

			if (img.src !== (img_src_value = /*bg*/ ctx[15].thumbnail
			? /*bg*/ ctx[15].thumbnail
			: /*bg*/ ctx[15].url)) attr(img, "src", img_src_value);

			attr(img, "alt", img_alt_value = "bg" + /*i*/ ctx[17]);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$bgList*/ 1 && img.src !== (img_src_value = /*bg*/ ctx[15].thumbnail
			? /*bg*/ ctx[15].thumbnail
			: /*bg*/ ctx[15].url)) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*$bgList*/ 1 && img_alt_value !== (img_alt_value = "bg" + /*i*/ ctx[17])) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
			mounted = false;
			dispose();
		}
	};
}

// (126:16) {#if bg.type === 'video'}
function create_if_block_1(ctx) {
	let video;
	let video_src_value;
	let video_alt_value;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[10](/*bg*/ ctx[15], ...args);
	}

	return {
		c() {
			video = element("video");
			attr(video, "class", "content svelte-1f9j6x");
			if (video.src !== (video_src_value = /*bg*/ ctx[15].url)) attr(video, "src", video_src_value);
			attr(video, "alt", video_alt_value = "bg" + /*i*/ ctx[17]);
			video.autoplay = true;
			video.muted = true;
			video.playsInline = true;
			video.loop = true;
		},
		m(target, anchor) {
			insert(target, video, anchor);

			if (!mounted) {
				dispose = listen(video, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$bgList*/ 1 && video.src !== (video_src_value = /*bg*/ ctx[15].url)) {
				attr(video, "src", video_src_value);
			}

			if (dirty & /*$bgList*/ 1 && video_alt_value !== (video_alt_value = "bg" + /*i*/ ctx[17])) {
				attr(video, "alt", video_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(video);
			mounted = false;
			dispose();
		}
	};
}

// (138:16) {#if bg.uploaded}
function create_if_block(ctx) {
	let button;
	let mounted;
	let dispose;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[13](/*i*/ ctx[17], ...args);
	}

	return {
		c() {
			button = element("button");

			button.innerHTML = `<i class="kalicon notranslate fill small svelte-1f9j6x">jellyfill</i> 
                    <i class="kalicon notranslate solid small svelte-1f9j6x">minus</i>`;

			attr(button, "class", "remove svelte-1f9j6x");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (117:10) {#each $bgList as bg, i (bg)}
function create_each_block(key_1, ctx) {
	let div1;
	let div0;
	let t;
	let div1_class_value;
	let div1_intro;
	let div1_outro;
	let rect;
	let stop_animation = noop;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*bg*/ ctx[15].type === "video") return create_if_block_1;
		if (/*bg*/ ctx[15].type === "img") return create_if_block_2;
		if (/*bg*/ ctx[15].type === "color") return create_if_block_3;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type && current_block_type(ctx);
	let if_block1 = /*bg*/ ctx[15].uploaded && create_if_block(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(div0, "class", "contentContainer svelte-1f9j6x");

			attr(div1, "class", div1_class_value = "bg " + (/*$bgURL*/ ctx[1].url === /*bg*/ ctx[15].url
			? "selected"
			: "") + " svelte-1f9j6x");

			set_style(div1, "--bg-color", /*bg*/ ctx[15].type === "color"
			? /*bg*/ ctx[15].url
			: "");

			this.first = div1;
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div1, t);
			if (if_block1) if_block1.m(div1, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div0, null);
				}
			}

			if (/*bg*/ ctx[15].uploaded) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*$bgURL, $bgList*/ 3 && div1_class_value !== (div1_class_value = "bg " + (/*$bgURL*/ ctx[1].url === /*bg*/ ctx[15].url
			? "selected"
			: "") + " svelte-1f9j6x")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$bgList*/ 1) {
				set_style(div1, "--bg-color", /*bg*/ ctx[15].type === "color"
				? /*bg*/ ctx[15].url
				: "");
			}
		},
		r() {
			rect = div1.getBoundingClientRect();
		},
		f() {
			fix_position(div1);
			stop_animation();
			add_transform(div1, rect);
		},
		a() {
			stop_animation();
			stop_animation = create_animation(div1, rect, flip, { duration: 300 });
		},
		i(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (div1_outro) div1_outro.end(1);
					if (!div1_intro) div1_intro = create_in_transition(div1, scale, { duration: 250 });
					div1_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			if (div1_intro) div1_intro.invalidate();

			if (local) {
				div1_outro = create_out_transition(div1, scale, { duration: 250 });
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) if_block1.d();
			if (detaching && div1_outro) div1_outro.end();
		}
	};
}

function create_fragment(ctx) {
	let container;
	let section;
	let div2;
	let label;
	let div0;
	let svg;
	let rect;
	let t0;
	let i;
	let div0_data_text_value;
	let t2;
	let input;
	let t3;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t4;
	let div1;
	let div1_intro;
	let div1_outro;
	let div2_intro;
	let div2_outro;
	let t5;
	let div3;
	let t6;
	let div4;
	let div4_intro;
	let div4_outro;
	let container_data_text_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*$bgList*/ ctx[0];
	const get_key = ctx => /*bg*/ ctx[15];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			container = element("container");
			section = element("section");
			div2 = element("div");
			label = element("label");
			div0 = element("div");
			svg = svg_element("svg");
			rect = svg_element("rect");
			t0 = space();
			i = element("i");
			i.textContent = "file";
			t2 = space();
			input = element("input");
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div1 = element("div");
			t5 = space();
			div3 = element("div");
			t6 = space();
			div4 = element("div");
			attr(rect, "class", "dotted svelte-1f9j6x");
			attr(rect, "x", "4");
			attr(rect, "y", "4");
			attr(rect, "width", "291");
			attr(rect, "height", "291");
			attr(rect, "rx", "20");
			attr(svg, "viewBox", "0 0 300 300");
			attr(svg, "class", "svelte-1f9j6x");
			attr(i, "class", "kalicon notranslate solid variable svelte-1f9j6x");
			attr(div0, "data-text", div0_data_text_value = subnav_bg_text.upload[/*$setLang*/ ctx[3]]);
			attr(div0, "class", "svelte-1f9j6x");
			attr(input, "type", "file");
			attr(input, "id", "uploadImage");
			attr(input, "name", "fileList");
			attr(input, "accept", ".jpg,.png,.mp4");
			attr(input, "class", "svelte-1f9j6x");
			attr(label, "class", "bg svelte-1f9j6x");
			attr(label, "for", "uploadImage");
			attr(div1, "class", "shadow svelte-1f9j6x");
			attr(div2, "class", "bg-list svelte-1f9j6x");
			attr(div3, "class", "spacer svelte-1f9j6x");
			attr(section, "class", "svelte-1f9j6x");
			attr(div4, "id", "picker");
			attr(div4, "class", "svelte-1f9j6x");
			attr(container, "data-text", container_data_text_value = subnav_bg_text.upload[/*$setLang*/ ctx[3]]);
			attr(container, "class", "svelte-1f9j6x");
			toggle_class(container, "drop_zone", /*$dropzone*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, container, anchor);
			append(container, section);
			append(section, div2);
			append(div2, label);
			append(label, div0);
			append(div0, svg);
			append(svg, rect);
			append(div0, t0);
			append(div0, i);
			append(label, t2);
			append(label, input);
			append(div2, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			append(div2, t4);
			append(div2, div1);
			append(section, t5);
			append(section, div3);
			append(container, t6);
			append(container, div4);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*handleClickUpload*/ ctx[7]);
				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!current || dirty & /*$setLang*/ 8 && div0_data_text_value !== (div0_data_text_value = subnav_bg_text.upload[/*$setLang*/ ctx[3]])) {
				attr(div0, "data-text", div0_data_text_value);
			}

			if (dirty & /*$bgURL, $bgList, removeImage, handleSelect*/ 99) {
				each_value = /*$bgList*/ ctx[0];
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div2, fix_and_outro_and_destroy_block, create_each_block, t4, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty & /*$setLang*/ 8 && container_data_text_value !== (container_data_text_value = subnav_bg_text.upload[/*$setLang*/ ctx[3]])) {
				attr(container, "data-text", container_data_text_value);
			}

			if (dirty & /*$dropzone*/ 4) {
				toggle_class(container, "drop_zone", /*$dropzone*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (div1_outro) div1_outro.end(1);

				if (!div1_intro) div1_intro = create_in_transition(div1, fade, {
					easing: cubicInOut,
					duration: 0,
					delay: 1000
				});

				div1_intro.start();
			});

			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);

				if (!div2_intro) div2_intro = create_in_transition(div2, fly, {
					x: /*$DIM*/ ctx[4].w > 600 ? 0 : 20,
					y: /*$DIM*/ ctx[4].w > 600 ? 20 : 0,
					easing: cubicInOut,
					duration: 400,
					delay: 200
				});

				div2_intro.start();
			});

			add_render_callback(() => {
				if (div4_outro) div4_outro.end(1);

				if (!div4_intro) div4_intro = create_in_transition(div4, fade, {
					easing: cubicInOut,
					duration: 0,
					delay: 1000
				});

				div4_intro.start();
			});

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (div1_intro) div1_intro.invalidate();
			div1_outro = create_out_transition(div1, fade, { duration: 0 });
			if (div2_intro) div2_intro.invalidate();

			div2_outro = create_out_transition(div2, fade, {
				duration: /*$DIM*/ ctx[4].w > 600 ? 200 : 0
			});

			if (div4_intro) div4_intro.invalidate();
			div4_outro = create_out_transition(div4, fade, { duration: 0 });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(container);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching && div1_outro) div1_outro.end();
			if (detaching && div2_outro) div2_outro.end();
			if (detaching && div4_outro) div4_outro.end();
			mounted = false;
			dispose();
		}
	};
}

const savedIro = writable("#fff");
getLocalStorage(savedIro, "savedIro", "#fff");
subLocalStorage(savedIro, "savedIro");

const handleBGImage = files => {
	for (var i = 0; i < files.length; i++) {
		let type = isImageVideo(files[i]);

		if (!type) {
			console.log("File format not supported.");

			notifText.set({
				type: "error",
				"text": "Backgrounds can only be .jpg, .png, or .mp4"
			});

			return;
		}

		const blob = URL.createObjectURL(files[i]);
		var reader = new FileReader();

		reader.onload = function (e) {
			let objectURL = e.target.result;
			bgURL.set({ type, data: objectURL, url: blob });

			bgList.set([
				{
					type,
					data: objectURL,
					url: blob,
					uploaded: true
				},
				...get(bgList)
			]);
		};

		reader.readAsDataURL(files[i]);
	}
};

function instance($$self, $$props, $$invalidate) {
	let $bgList;
	let $bgURL;

	let $savedIro,
		$$unsubscribe_savedIro = noop,
		$$subscribe_savedIro = () => ($$unsubscribe_savedIro(), $$unsubscribe_savedIro = subscribe(savedIro, $$value => $$invalidate(14, $savedIro = $$value)), savedIro);

	let $breakpoint;
	let $dropzone;
	let $setLang;
	let $DIM;
	component_subscribe($$self, bgList, $$value => $$invalidate(0, $bgList = $$value));
	component_subscribe($$self, bgURL, $$value => $$invalidate(1, $bgURL = $$value));
	component_subscribe($$self, savedIro, $$value => $$invalidate(14, $savedIro = $$value));
	component_subscribe($$self, breakpoint, $$value => $$invalidate(9, $breakpoint = $$value));
	component_subscribe($$self, dropzone, $$value => $$invalidate(2, $dropzone = $$value));
	component_subscribe($$self, setLang, $$value => $$invalidate(3, $setLang = $$value));
	component_subscribe($$self, DIM, $$value => $$invalidate(4, $DIM = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_savedIro());

	const removeImage = i => {
		let newArray = $bgList;
		newArray.splice(i, 1);

		if (i > -1) {
			set_store_value(bgList, $bgList = newArray, $bgList);
		}
	};

	const handleSelect = content => {
		if ($bgURL.url === content.url) {
			return;
		}

		bgURL.set({
			type: content.type,
			data: content.data,
			url: content.url
		});
	};

	const handleClickUpload = e => {
		handleBGImage(e.target.files);
	};

	let colorPicker;

	onMount(() => {
		$$invalidate(8, colorPicker = new iro.ColorPicker("#picker",
		{
				layout: [{ component: iro.ui.Wheel }, { component: iro.ui.Slider }],
				display: "flex",
				width: 126,
				color: $savedIro,
				borderWidth: 0,
				borderColor: "var(--offblack)"
			}));

		colorPicker.forceUpdate();

		colorPicker.on("color:change", function (color) {
			savedIro.set(color.hexString);
			bgURL.set({ type: "iro", url: color.hexString });
		});
	});

	const click_handler = (bg, e) => {
		e.preventDefault;
		handleSelect(bg);
	};

	const click_handler_1 = (bg, e) => {
		e.preventDefault;
		handleSelect(bg);
	};

	const click_handler_2 = (bg, e) => {
		e.preventDefault;
		handleSelect(bg);
	};

	const click_handler_3 = (i, e) => {
		e.preventDefault;
		removeImage(i);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*colorPicker, $breakpoint*/ 768) {
			$: {
				if (colorPicker && $breakpoint) {
					$$invalidate(8, colorPicker.state.layoutDirection = $breakpoint === "desktop" ? "vertical" : "horizontal", colorPicker);
					colorPicker.forceUpdate();
				}
			}
		}
	};

	return [
		$bgList,
		$bgURL,
		$dropzone,
		$setLang,
		$DIM,
		removeImage,
		handleSelect,
		handleClickUpload,
		colorPicker,
		$breakpoint,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class Sub_nav_bg extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Sub_nav_bg;
export { savedIro, handleBGImage };