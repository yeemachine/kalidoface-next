import './SVGWipe.svelte.css.proxy.js';
/* src/components/SVGWipe.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	attr,
	binding_callbacks,
	component_subscribe,
	create_slot,
	detach,
	flush,
	init as init_1,
	insert,
	safe_not_equal,
	svg_element,
	transition_in,
	transition_out,
	update_slot
} from "../../_snowpack/pkg/svelte/internal.js";

import { onMount } from "../../_snowpack/pkg/svelte.js";
import { tweened } from "../../_snowpack/pkg/svelte/motion.js";
import { cubicInOut, linear } from "../../_snowpack/pkg/svelte/easing.js";

function create_fragment(ctx) {
	let svg;
	let svg_data_axis_value;
	let svg_data_flip_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			attr(svg, "class", "shape-overlays svelte-19kx5c6");
			attr(svg, "viewBox", "0 0 100 100");
			attr(svg, "data-axis", svg_data_axis_value = /*isHorizontal*/ ctx[1] ? "x" : "y");
			attr(svg, "data-flip", svg_data_flip_value = /*flip*/ ctx[2] ? true : false);
			attr(svg, "preserveAspectRatio", "none");
		},
		m(target, anchor) {
			insert(target, svg, anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			/*svg_binding*/ ctx[9](svg);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], !current ? -1 : dirty, null, null);
				}
			}

			if (!current || dirty & /*isHorizontal*/ 2 && svg_data_axis_value !== (svg_data_axis_value = /*isHorizontal*/ ctx[1] ? "x" : "y")) {
				attr(svg, "data-axis", svg_data_axis_value);
			}

			if (!current || dirty & /*flip*/ 4 && svg_data_flip_value !== (svg_data_flip_value = /*flip*/ ctx[2] ? true : false)) {
				attr(svg, "data-flip", svg_data_flip_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
			/*svg_binding*/ ctx[9](null);
		}
	};
}

let delayPerPath = 0.125; //percentage of timeline

function instance($$self, $$props, $$invalidate) {
	let $timeline;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { transition = false } = $$props; //locked until animation finishes
	let svgDom;
	let paths = [];
	let allPoints = [[], [], []];
	let pointsDelay = [];
	let numPaths = 0;
	let numPoints = 5;
	let duration = 1200; //total animation in ms
	let delayPointsMax = 0.5; //percentage of path timeline
	let { isOpen = false } = $$props;
	let curveStyle = "curve";
	let wipe = false;
	let isHorizontal = false;
	let flip = false;
	const timeline = tweened(0, { duration: 1000, easing: linear });
	component_subscribe($$self, timeline, value => $$invalidate(18, $timeline = value));

	const animate = ({ axis = "x", _duration = 1200, _delayPointsMax = 0.15, _delayPerPath = 0.125, action = null, _wipe = false, _flip = false, _curve = "curve", pattern = [], _numPoints = 5 } = {}) => {
		//do not fire when transitioning
		if (!transition) {
			//optional param overrides
			$$invalidate(1, isHorizontal = axis === "x" ? true : false);

			duration = _duration;
			numPoints = _numPoints;
			curveStyle = _curve;
			delayPointsMax = _delayPointsMax;
			delayPointsMax = _delayPerPath;

			$$invalidate(5, isOpen = action === "open"
			? false
			: action === "close" ? true : isOpen);

			wipe = _wipe;
			$$invalidate(2, flip = _flip);
			svgDom.setAttribute("data-axis", axis);
			svgDom.setAttribute("data-flip", _flip);

			//optional delay pattern array for less randomized waves
			if (pattern.length >= numPoints) {
				pointsDelay = pattern;
			} else {
				createRandomness();
			}

			//start transition, lock function
			$$invalidate(4, transition = true);

			//reset timeline
			timeline.set(0, { duration: 0 });

			//trigger timeline animation
			timeline.set(1, { duration });
		}
	};

	const createRandomness = () => {
		for (let i = 0; i < numPoints; i++) {
			pointsDelay[i] = Math.random() * delayPointsMax;
		}
	};

	//split single timeline into multi layered complex timeline
	const calcTimeline = t => {
		let allPoints = [[], [], []];
		let pathRange = 1 - delayPerPath * (numPaths - 1);

		//map path val from 0 to 1
		for (let i = 0; i < numPaths; i++) {
			let pathDelay = delayPerPath * (isOpen ? i : numPaths - i - 1);
			let pathVal = (t - pathDelay) / pathRange;
			pathVal = Math.min(Math.max(pathVal, 0), 1);

			//map point val from 0 to 1 based on mapped path val
			for (let j = 0; j < numPoints; j++) {
				let pointVal = (pathVal - pointsDelay[j]) / (1 - delayPointsMax);
				pointVal = Math.min(Math.max(pointVal, 0), 1);
				allPoints[numPaths - i - 1][j] = cubicInOut(pointVal) * 100;
			}
		}

		return allPoints;
	};

	//draw svg
	const render = (paths = [], allPoints = []) => {
		for (var i = 0; i < numPaths; i++) {
			var path = paths[i];
			var points = allPoints[i];
			var d = "";

			//first vector point
			switch (curveStyle) {
				case "curve":
					d += isHorizontal
					? isOpen
						? `M 100 0 H ${points[0]} C`
						: `M 0 0 H ${points[0]} C`
					: isOpen ? `M 0 0 V ${points[0]} C` : `M 0 ${points[0]} C`;
					break;
				case "step":
					d += isHorizontal
					? isOpen
						? `M 100 0 H ${points[0]} L`
						: `M 0 0 H ${points[0]} L`
					: isOpen ? `M 0 0 V ${points[0]} L` : `M 0 ${points[0]} L`;
					break;
				case "zigzag":
					d += isHorizontal
					? isOpen
						? `M 100 0 H ${points[0]} L`
						: `M 0 0 H ${points[0]} L`
					: isOpen ? `M 0 0 V ${points[0]} L` : `M 0 ${points[0]} L`;
					break;
				default:
					d += isHorizontal
					? isOpen
						? `M 100 0 H ${points[0]} C`
						: `M 0 0 H ${points[0]} C`
					: isOpen ? `M 0 0 V ${points[0]} C` : `M 0 ${points[0]} C`;
					break;
			}

			//staggered path points
			for (var j = 0; j < numPoints - 1; j++) {
				var p = (j + 1) / (numPoints - 1) * 100;
				var cp = p - 1 / (numPoints - 1) * 100 / 2;

				switch (curveStyle) {
					case "curve":
						d += isHorizontal
						? ` ${points[j]} ${cp} ${points[j + 1]} ${cp}  ${points[j + 1]} ${p}`
						: ` ${cp} ${points[j]} ${cp} ${points[j + 1]} ${p} ${points[j + 1]}`;
						break;
					case "step":
						d += isHorizontal
						? ` ${points[j]} ${cp} ${points[j + 1]} ${cp}  ${points[j + 1]} ${p}`
						: ` ${cp} ${points[j]} ${cp} ${points[j + 1]} ${p} ${points[j + 1]}`;
						break;
					case "zigzag":
						d += isHorizontal
						? ` ${points[j]} ${cp} ${points[j + 1]} ${p}`
						: ` ${cp} ${points[j]} ${p} ${points[j + 1]}`;
						break;
					default:
						d += isHorizontal
						? ` ${points[j]} ${cp} ${points[j + 1]} ${cp}  ${points[j + 1]} ${p}`
						: ` ${cp} ${points[j]} ${cp} ${points[j + 1]} ${p} ${points[j + 1]}`;
						break;
				}
			}

			//last vector point
			d += isHorizontal
			? isOpen ? ` V 100 H 100` : ` V 100 H 0`
			: isOpen ? ` V 100 H 0` : ` V 0 H 0`;

			path.setAttribute("d", d);
		}
	};

	//handle changes to timeline
	timeline.subscribe(t => {
		let newPoints = calcTimeline(t);

		if (paths.length > 0) {
			render(paths, newPoints);
		}

		if (t === 1) {
			$$invalidate(5, isOpen = !isOpen);

			if (wipe) {
				wipe = false;
				timeline.set(0, { duration: 0 });
				timeline.set(1, { duration });
			} else {
				$$invalidate(4, transition = false);
			}
		}
	});

	//initialize paths and numpaths
	const init = () => {
		paths = svgDom.querySelectorAll(".shape-overlays__path");
		numPaths = paths.length;
		createRandomness();

		if (paths.length > 0) {
			let newPoints = calcTimeline($timeline);
			render(paths, newPoints);
		}
	};

	onMount(() => {
		init();
	});

	function svg_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			svgDom = $$value;
			$$invalidate(0, svgDom);
		});
	}

	$$self.$$set = $$props => {
		if ("transition" in $$props) $$invalidate(4, transition = $$props.transition);
		if ("isOpen" in $$props) $$invalidate(5, isOpen = $$props.isOpen);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		svgDom,
		isHorizontal,
		flip,
		timeline,
		transition,
		isOpen,
		animate,
		$$scope,
		slots,
		svg_binding
	];
}

class SVGWipe extends SvelteComponent {
	constructor(options) {
		super();
		init_1(this, options, instance, create_fragment, safe_not_equal, { transition: 4, isOpen: 5, animate: 6 });
	}

	get transition() {
		return this.$$.ctx[4];
	}

	set transition(transition) {
		this.$set({ transition });
		flush();
	}

	get isOpen() {
		return this.$$.ctx[5];
	}

	set isOpen(isOpen) {
		this.$set({ isOpen });
		flush();
	}

	get animate() {
		return this.$$.ctx[6];
	}
}

export default SVGWipe;