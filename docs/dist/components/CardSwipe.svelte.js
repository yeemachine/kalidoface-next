import './CardSwipe.svelte.css.proxy.js';
/* src/components/CardSwipe.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_in_transition,
	create_out_transition,
	create_slot,
	detach,
	element,
	group_outros,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text,
	transition_in,
	transition_out,
	update_slot
} from "../../_snowpack/pkg/svelte/internal.js";

import interact from "../../_snowpack/pkg/interactjs.js";
import { onMount } from "../../_snowpack/pkg/svelte.js";
import { fade, scale } from "../../_snowpack/pkg/svelte/transition.js";
import { cubicInOut } from "../../_snowpack/pkg/svelte/easing.js";
import { getCSSCustomProp } from "../utils/helpers.js";
import { DIM, setLang } from "../stores.js";
import { cardEndText } from "../text/translations.js";

function create_if_block(ctx) {
	let div;

	let t_value = (/*cards*/ ctx[2]
	? /*cards*/ ctx[2].length - /*currentCard*/ ctx[1] - 1
	: "0") + "";

	let t;
	let div_intro;
	let div_outro;
	let current;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "counter svelte-beijvx");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if ((!current || dirty & /*cards, currentCard*/ 6) && t_value !== (t_value = (/*cards*/ ctx[2]
			? /*cards*/ ctx[2].length - /*currentCard*/ ctx[1] - 1
			: "0") + "")) set_data(t, t_value);
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);

				if (!div_intro) div_intro = create_in_transition(div, scale, {
					delay: 400,
					duration: 300,
					easing: cubicInOut
				});

				div_intro.start();
			});

			current = true;
		},
		o(local) {
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, scale, { duration: 300, easing: cubicInOut });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_outro) div_outro.end();
		}
	};
}

function create_fragment(ctx) {
	let main;
	let container_1;
	let t0;
	let button;
	let span;
	let t2;
	let t3_value = cardEndText.refresh[/*$setLang*/ ctx[4]] + "";
	let t3;
	let t4;
	let main_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let if_block = /*cards*/ ctx[2] && /*cards*/ ctx[2].length - /*currentCard*/ ctx[1] - 1 > 0 && create_if_block(ctx);

	return {
		c() {
			main = element("main");
			container_1 = element("container");
			if (default_slot) default_slot.c();
			t0 = space();
			button = element("button");
			span = element("span");
			span.textContent = "refresh";
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			attr(span, "class", "kalicon notranslate svelte-beijvx");
			attr(button, "class", "no_highlights svelte-beijvx");

			attr(main, "class", main_class_value = "container " + (/*cards*/ ctx[2] && /*currentCard*/ ctx[1] === /*cards*/ ctx[2].length
			? "done"
			: "") + " svelte-beijvx");

			set_style(main, "--maxWidth", Math.max(/*$DIM*/ ctx[3].w, /*$DIM*/ ctx[3].h) + "px");

			set_style(main, "--progress", /*cards*/ ctx[2]
			? /*currentCard*/ ctx[1] / /*cards*/ ctx[2].length
			: 0);
		},
		m(target, anchor) {
			insert(target, main, anchor);
			append(main, container_1);

			if (default_slot) {
				default_slot.m(container_1, null);
			}

			append(container_1, t0);
			append(container_1, button);
			append(button, span);
			append(button, t2);
			append(button, t3);
			append(container_1, t4);
			if (if_block) if_block.m(container_1, null);
			/*main_binding*/ ctx[8](main);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", /*resetStack*/ ctx[5]),
					listen(button, "touchend", /*resetStack*/ ctx[5], { passive: true })
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], !current ? -1 : dirty, null, null);
				}
			}

			if ((!current || dirty & /*$setLang*/ 16) && t3_value !== (t3_value = cardEndText.refresh[/*$setLang*/ ctx[4]] + "")) set_data(t3, t3_value);

			if (/*cards*/ ctx[2] && /*cards*/ ctx[2].length - /*currentCard*/ ctx[1] - 1 > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*cards, currentCard*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(container_1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*cards, currentCard*/ 6 && main_class_value !== (main_class_value = "container " + (/*cards*/ ctx[2] && /*currentCard*/ ctx[1] === /*cards*/ ctx[2].length
			? "done"
			: "") + " svelte-beijvx")) {
				attr(main, "class", main_class_value);
			}

			if (!current || dirty & /*$DIM*/ 8) {
				set_style(main, "--maxWidth", Math.max(/*$DIM*/ ctx[3].w, /*$DIM*/ ctx[3].h) + "px");
			}

			if (!current || dirty & /*cards, currentCard*/ 6) {
				set_style(main, "--progress", /*cards*/ ctx[2]
				? /*currentCard*/ ctx[1] / /*cards*/ ctx[2].length
				: 0);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(main);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*main_binding*/ ctx[8](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const interactThreshold = 100;
const interactMaxRotation = 15;

function transitionListener(event) {
	event.target.style.setProperty("--card-r", "");
	event.target.style.setProperty("--card-x", "");
	event.target.style.setProperty("--card-y", "");
	event.target.setAttribute("data-status", "waiting");
	event.target.removeEventListener("transitionend", transitionListener);
}

function instance($$self, $$props, $$invalidate) {
	let $DIM;
	let $setLang;
	component_subscribe($$self, DIM, $$value => $$invalidate(3, $DIM = $$value));
	component_subscribe($$self, setLang, $$value => $$invalidate(4, $setLang = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let container;
	let currentCard = 0;
	let cards;
	let rotation = 0;
	let x = 0;
	let y = 0;

	const resetStack = () => {
		cards[0].setAttribute("data-loop", "peak");
		cards[0].setAttribute("data-status", "current");
		$$invalidate(1, currentCard = 0);
	};

	function dragMoveListener(event) {
		// console.log(x,y)
		var target = event.target;

		// keep the dragged position in the custom properties
		x = (getCSSCustomProp("--card-x", target, "float") || 0) + event.dx;

		y = (getCSSCustomProp("--card-y", target, "float") || 0) + event.dy;

		// add rotation based on card position
		rotation = interactMaxRotation * (x / interactThreshold);

		if (rotation > interactMaxRotation) rotation = interactMaxRotation; else if (rotation < -interactMaxRotation) rotation = -interactMaxRotation;

		// update styles
		target.style.setProperty("--card-x", x + "px");

		target.style.setProperty("--card-y", y + "px");
		target.style.setProperty("--card-r", rotation + "deg");
	}

	onMount(() => {
		$$invalidate(2, cards = document.querySelectorAll(".card"));

		// get viewport width
		interact(".card[data-status=\"current\"]").unset();

		// interact.js
		interact(".card[data-status=\"current\"]").styleCursor(false).draggable({
			onstart: () => {
				// signify dragging
				event.target.setAttribute("data-dragging", true);
			},
			// call this function on every dragmove event
			onmove: dragMoveListener,
			// call this function on every dragend event
			onend: event => {
				const vw = document.documentElement.clientWidth;

				// create an off canvas x coordinate
				const offX = vw < 500 ? 500 : vw;

				$$invalidate(2, cards = event.target.parentNode.querySelectorAll(".card"));
				const index = [...cards].indexOf(event.target);

				// signify dragging stopped
				event.target.setAttribute("data-dragging", false);

				// calculate how far card moved
				let moved = Math.sqrt(Math.pow(event.pageX - event.x0, 2) + Math.pow(event.pageY - event.y0, 2) | 0);

				if (moved > interactThreshold) {
					// remove card
					event.target.setAttribute("data-status", "transition");

					if (x > 0) {
						x = offX;
					} else {
						x = offX * -1;
					}

					// mark as done after CSS transition
					event.target.addEventListener("transitionend", transitionListener);

					// activate next card
					if (index < cards.length - 1) {
						cards[index + 1].setAttribute("data-status", "current");
						$$invalidate(1, currentCard = index + 1);
					} else {
						$$invalidate(1, currentCard = index + 1);
					} // cards[0].setAttribute('data-status', 'current');
					// currentCard=0

					if (index === cards.length - 1) {
						cards[0].setAttribute("data-loop", "load");
					} else {
						cards[0].setAttribute("data-loop", "");
					}
				} else {
					// reset vars
					x = 0;

					y = 0;
					rotation = 0;

					// update rotation
					event.target.style.setProperty("--card-r", rotation + "deg");
				}

				// update x and y pos
				event.target.style.setProperty("--card-x", x + "px");

				event.target.style.setProperty("--card-y", y + "px");
			}
		});
	});

	function main_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		container,
		currentCard,
		cards,
		$DIM,
		$setLang,
		resetStack,
		$$scope,
		slots,
		main_binding
	];
}

class CardSwipe extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default CardSwipe;