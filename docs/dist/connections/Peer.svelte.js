import './Peer.svelte.css.proxy.js';
/* src/connections/Peer.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	attr,
	component_subscribe,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal,
	set_store_value,
	subscribe
} from "../../_snowpack/pkg/svelte/internal.js";

import { writable } from "../../_snowpack/pkg/svelte/store.js";
import { onMount } from "../../_snowpack/pkg/svelte.js";
import { DIM } from "../stores.js";
import { userModel, friendModel } from "../scene/character.svelte.js";
import { profiles } from "../scene/profiles.svelte.js";
import { spring } from "../../_snowpack/pkg/svelte/motion.js";
import faceMap, { stabilizeBlink } from "../utils/faceMap/index.js";
import { initCounter, counter, resetTimer } from "./timer.js";
import { randomString } from "../utils/helpers.js";
import Peer from "../../_snowpack/pkg/peerjs.js";
import { notifText } from "../ui/notif.svelte.js";
import { friend_smooth_face } from "../tracking/smoothFriend.svelte.js";
import { expandXYZ } from "../tracking/sendTrackingToPeer.svelte.js";
import { updatePos } from "../scene/pixi.live2d.utils.js";

function create_fragment(ctx) {
	let audio;

	return {
		c() {
			audio = element("audio");
			attr(audio, "class", "remote-audio svelte-937zs6");
			audio.controls = true;
			audio.autoplay = true;
		},
		m(target, anchor) {
			insert(target, audio, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(audio);
		}
	};
}

const p2pConnection = writable(null);
const inputID = writable("");
const myID = writable(null);
const friendID = writable(null);
const PEER = writable(null);
const peerState = writable("default");
const callTime = writable("0:00");
const isHost = writable(false);
let extconn = null;

function instance($$self, $$props, $$invalidate) {
	let $profiles;
	let $DIM;

	let $friendID,
		$$unsubscribe_friendID = noop,
		$$subscribe_friendID = () => ($$unsubscribe_friendID(), $$unsubscribe_friendID = subscribe(friendID, $$value => $$invalidate(5, $friendID = $$value)), friendID);

	let $userModel;

	let $p2pConnection,
		$$unsubscribe_p2pConnection = noop,
		$$subscribe_p2pConnection = () => ($$unsubscribe_p2pConnection(), $$unsubscribe_p2pConnection = subscribe(p2pConnection, $$value => $$invalidate(7, $p2pConnection = $$value)), p2pConnection);

	component_subscribe($$self, profiles, $$value => $$invalidate(3, $profiles = $$value));
	component_subscribe($$self, DIM, $$value => $$invalidate(4, $DIM = $$value));
	component_subscribe($$self, friendID, $$value => $$invalidate(5, $friendID = $$value));
	component_subscribe($$self, userModel, $$value => $$invalidate(6, $userModel = $$value));
	component_subscribe($$self, p2pConnection, $$value => $$invalidate(7, $p2pConnection = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_friendID());
	$$self.$$.on_destroy.push(() => $$unsubscribe_p2pConnection());

	peerState.subscribe(e => {
		if (e === "connected") {
			if (!counter) {
				initCounter();
			}
		} else {
			resetTimer();
		}
	});

	let friend_smoothPos = spring(
		{
			position: { x: 0.5, y: 0.5, z: 0 },
			zoom: 0.2
		},
		{
			stiffness: 0.15,
			damping: 0.7,
			precision: 0.1
		}
	);

	friend_smoothPos.subscribe(val => {
		if (!$profiles.friend.destroying) {
			set_store_value(profiles, $profiles.friend.position.x = val.position.x, $profiles);
			set_store_value(profiles, $profiles.friend.position.y = val.position.y, $profiles);
			set_store_value(profiles, $profiles.friend.zoom = val.zoom, $profiles);

			updatePos($profiles.friend.live2d, {
				width: $DIM.cw,
				height: $DIM.ch,
				zoom: $profiles.friend.zoom,
				position: $profiles.friend.position
			});
		}
	});

	let localStream, remoteStream;
	let rString = randomString(6, "0123456789");
	let currentConnection = null;
	myID.set(rString);

	let peer = new Peer(rString,
	{
			host: "kalidoface-peer.glitch.me",
			path: "/peerjs/myapp",
			config: {
				iceServers: [{ urls: "stun:stun.stunprotocol.org" }]
			}
		});

	PEER.set(peer);

	friendID.subscribe(val => {
		if (val) {
			connectToPeer(val);
		}
	});

	const connectToPeer = id => {
		// let id = findURLParams().room;
		console.log(`Connecting to ${id}...`);

		// console.log(peer)
		let outConn = peer.connect(id);

		// console.log(outConn)
		handleConn(outConn);

		isHost.set(true);

		navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(stream => {
			localStream = stream;
			let call = peer.call(id, stream);
			call.on("stream", renderAudio);
		}).catch(err => {
			
		}); // logMessage('Failed to get local stream', err);
	};

	const handleDisconn = () => {
		stopStream();

		// console.log('disconnected')
		friendModel.set(null);

		friendID.set(null);
		p2pConnection.set(null);
		isHost.set(false);
		peerState.set("default");
	};

	const stopStream = () => {
		if (localStream) {
			localStream.getAudioTracks().forEach(track => track.stop());
		} // console.log(localStream.getAudioTracks())

		if (remoteStream) {
			remoteStream.getAudioTracks().forEach(track => track.stop());
		} // console.log(remoteStream.getAudioTracks())
	};

	const renderAudio = stream => {
		document.querySelector("audio").srcObject = stream;
		document.querySelector("audio").play();
	};

	const handleConn = (conn, id) => {
		currentConnection = conn;
		p2pConnection.set(currentConnection);

		// peerID.set(conn.peer)
		peerState.set("connecting");

		conn.on("data", data => {
			// console.log(data)
			if (data.type === "modelObj") {
				console.log(JSON.parse(atob(data.res)));
				friendModel.set(JSON.parse(atob(data.res)));
				peerState.set("connected");
			}

			if (data.type === "face" || data.type === "holistic") {
				friend_smooth_face.set({
					eye: { l: data.eyeL, r: data.eyeR },
					mouth: {
						x: data.mouthX,
						y: data.mouthY,
						shape: {
							A: data.mouthA,
							E: data.mouthE,
							I: data.mouthI,
							O: data.mouthO,
							U: data.mouthU
						}
					},
					head: {
						x: data.headX,
						y: data.headY,
						z: data.headZ
					},
					brow: data.brow,
					pupil: { x: data.pupilX, y: data.pupilY }
				});

				set_store_value(profiles, $profiles.friend.tracking.pose.enable = true, $profiles);
				set_store_value(profiles, $profiles.friend.detected = data.detected, $profiles);
			}

			if (data.type === "position") {
				friend_smoothPos.set({
					position: {
						x: data.res.positionX,
						y: data.res.positionY
					},
					zoom: data.res.zoom
				});
			}
		});

		conn.on("open", () => {
			conn.send("hello!");

			if ($friendID) {
				conn.send({ res: $friendID, type: "id" });
			}

			if (typeof $userModel === "object") {
				let base64 = btoa(JSON.stringify($userModel));
				conn.send({ res: base64, type: "modelObj" });
			}

			conn.send({
				res: {
					positionX: $profiles.user.position.x,
					positionY: $profiles.user.position.y,
					zoom: $profiles.user.zoom
				},
				type: "position"
			});
		});

		conn.on("close", () => {
			// console.log('peer-disconnected')
			handleDisconn();
		});
	};

	peer.on("open", id => {
		console.log("My Chat ID is: " + id);
		peerState.set("default");
	});

	peer.on("error", error => {
		if (error.message.includes("Could not connect to peer")) {
			notifText.set({
				type: "error",
				"text": "Could not connect to Chat ID"
			});

			handleDisconn();
		}

		console.error(error);
	});

	peer.on("disconnected", val => {
		handleDisconn();
		peerState.set("server-disconnect");
	});

	peer.on("close", val => {
		
	}); // console.log('Connection Destroyed')

	// Handle incoming data connection
	peer.on("connection", conn => {
		// console.log('incoming peer connection!');  
		handleConn(conn);

		isHost.set(false);
		console.log("being connect to");
		inputID.set(conn.peer);
	});

	peer.on("call", call => {
		navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(stream => {
			remoteStream = stream;
			call.answer(stream); // Answer the call with an A/V stream.
			call.on("stream", renderAudio);
		}).catch(err => {
			console.error("Failed to get local stream", err);
		});
	});

	userModel.subscribe(e => {
		if ($p2pConnection) {
			if (typeof e === "object") {
				let base64 = btoa(JSON.stringify(e));
				$p2pConnection.send({ res: base64, type: "modelObj" });
			}
		} // if(typeof e === 'string'){
		//   $p2pConnection.send({
	}); //     res: e,
	//     type: 'modelString'
	//   })
	// }

	return [];
}

class Peer_1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Peer_1;

export {
	p2pConnection,
	inputID,
	myID,
	friendID,
	PEER,
	peerState,
	callTime,
	isHost
};