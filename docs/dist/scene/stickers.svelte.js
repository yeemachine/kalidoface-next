import './stickers.svelte.css.proxy.js';
/* src/scene/stickers.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	check_outros,
	component_subscribe,
	create_in_transition,
	create_out_transition,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	noop,
	outro_and_destroy_block,
	safe_not_equal,
	set_style,
	space,
	subscribe,
	transition_in,
	transition_out,
	update_keyed_each
} from "../../_snowpack/pkg/svelte/internal.js";

import { createBlobURL } from "../utils/helpers.js";
import { urlBase, getLocalStorage, subLocalStorage } from "../stores.js";
import { writable, get } from "../../_snowpack/pkg/svelte/store.js";
import { onMount } from "../../_snowpack/pkg/svelte.js";
import { fade, scale } from "../../_snowpack/pkg/svelte/transition.js";
import { cubicInOut } from "../../_snowpack/pkg/svelte/easing.js";
import interact from "../../_snowpack/pkg/interactjs.js";
import { DIM } from "../stores.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (194:2) {:else}
function create_else_block(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "content svelte-17zb432");
			if (img.src !== (img_src_value = /*sticker*/ ctx[3].url)) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = "preset sticker" + /*sticker*/ ctx[3].id);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "contextmenu", contextmenu_handler_1);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$stickerLayers*/ 1 && img.src !== (img_src_value = /*sticker*/ ctx[3].url)) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*$stickerLayers*/ 1 && img_alt_value !== (img_alt_value = "preset sticker" + /*sticker*/ ctx[3].id)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
			mounted = false;
			dispose();
		}
	};
}

// (189:2) {#if sticker.type==="video"}
function create_if_block(ctx) {
	let video;
	let video_src_value;
	let video_alt_value;
	let mounted;
	let dispose;

	return {
		c() {
			video = element("video");
			attr(video, "class", "content svelte-17zb432");
			if (video.src !== (video_src_value = /*sticker*/ ctx[3].url)) attr(video, "src", video_src_value);
			attr(video, "alt", video_alt_value = "uploaded sticker" + /*sticker*/ ctx[3].id);
			video.autoplay = true;
			video.muted = true;
			video.playsInline = true;
			video.loop = true;
		},
		m(target, anchor) {
			insert(target, video, anchor);

			if (!mounted) {
				dispose = listen(video, "contextmenu", contextmenu_handler);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$stickerLayers*/ 1 && video.src !== (video_src_value = /*sticker*/ ctx[3].url)) {
				attr(video, "src", video_src_value);
			}

			if (dirty & /*$stickerLayers*/ 1 && video_alt_value !== (video_alt_value = "uploaded sticker" + /*sticker*/ ctx[3].id)) {
				attr(video, "alt", video_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(video);
			mounted = false;
			dispose();
		}
	};
}

// (184:0) {#each $stickerLayers as sticker (sticker.id)}
function create_each_block(key_1, ctx) {
	let div;
	let t;
	let div_data_id_value;
	let div_data_z_value;
	let div_intro;
	let div_outro;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*sticker*/ ctx[3].type === "video") return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			if_block.c();
			t = space();
			attr(div, "class", "resize-drag svelte-17zb432");
			set_style(div, "max-width", Math.min(/*$DIM*/ ctx[1].w * 0.5, 300) + "px");
			set_style(div, "z-index", /*sticker*/ ctx[3].zIndex);
			attr(div, "data-id", div_data_id_value = /*sticker*/ ctx[3].id);
			attr(div, "data-z", div_data_z_value = /*sticker*/ ctx[3].zIndex);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
			append(div, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, t);
				}
			}

			if (!current || dirty & /*$DIM*/ 2) {
				set_style(div, "max-width", Math.min(/*$DIM*/ ctx[1].w * 0.5, 300) + "px");
			}

			if (!current || dirty & /*$stickerLayers*/ 1) {
				set_style(div, "z-index", /*sticker*/ ctx[3].zIndex);
			}

			if (!current || dirty & /*$stickerLayers*/ 1 && div_data_id_value !== (div_data_id_value = /*sticker*/ ctx[3].id)) {
				attr(div, "data-id", div_data_id_value);
			}

			if (!current || dirty & /*$stickerLayers*/ 1 && div_data_z_value !== (div_data_z_value = /*sticker*/ ctx[3].zIndex)) {
				attr(div, "data-z", div_data_z_value);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, scale, { duration: 300, easing: cubicInOut });
				div_intro.start();
			});

			current = true;
		},
		o(local) {
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, scale, { duration: 300, easing: cubicInOut });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
			if (detaching && div_outro) div_outro.end();
		}
	};
}

function create_fragment(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*$stickerLayers*/ ctx[0];
	const get_key = ctx => /*sticker*/ ctx[3].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*Math, $DIM, $stickerLayers, cubicInOut*/ 3) {
				each_value = /*$stickerLayers*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

const stickerList = writable([
	//accessories
	{
		url: urlBase + "Stickers/accessories/sunglass_normal.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/accessories/birthday_party_sunglass.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/accessories/medical_mask_front_view.png",
		default: 0.5
	},
	//furniture
	{
		url: urlBase + "Stickers/furniture/table_syoumen_wood.png",
		default: 0.5
	},
	//food
	{
		url: urlBase + "Stickers/food/potatochips_fukuro_red.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/food/sweets_marzipan_cake.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/food/sweets_purin_cup.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/food/snackgashi.png",
		default: 0.5
	},
	//music
	{
		url: urlBase + "Stickers/drink/cafe_coffee_cup.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/drink/drink_cocktail09.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/drink/drink_cocktail10.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/drink/drink_sangria.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/drink/wine_bottle_bourgogne.png",
		default: 0.5
	},
	//music
	{
		url: urlBase + "Stickers/music/music_mic_stand.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/music/pen_light2_3_lime.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/music/music_guitar_doubleneck.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/music/gassyou_fumendai.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/music/music_mixer_dj.png",
		default: 0.5
	},
	{
		url: urlBase + "Stickers/music/animal_penguin_music_band.png",
		default: 0.5
	}
]);

getLocalStorage(stickerList, "stickerList", get(stickerList), createBlobURL);
subLocalStorage(stickerList, "stickerList");
const stickerLayers = writable([]);

function dragMoveListener(event) {
	var target = event.target,
		// keep the dragged position in the data-x/data-y attributes
		x = (parseFloat(target.getAttribute("data-x")) || 0) + event.dx,
		y = (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;

	// translate the element
	target.style.webkitTransform = target.style.transform = "translate(" + x + "px, " + y + "px)";

	// update the posiion attributes
	target.setAttribute("data-x", x);

	target.setAttribute("data-y", y);
}

const contextmenu_handler = e => {
	e.preventDefault();
	return false;
};

const contextmenu_handler_1 = e => {
	e.preventDefault();
	return false;
};

function instance($$self, $$props, $$invalidate) {
	let $stickerLayers,
		$$unsubscribe_stickerLayers = noop,
		$$subscribe_stickerLayers = () => ($$unsubscribe_stickerLayers(), $$unsubscribe_stickerLayers = subscribe(stickerLayers, $$value => $$invalidate(0, $stickerLayers = $$value)), stickerLayers);

	let $DIM;
	component_subscribe($$self, stickerLayers, $$value => $$invalidate(0, $stickerLayers = $$value));
	component_subscribe($$self, DIM, $$value => $$invalidate(1, $DIM = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_stickerLayers());

	const bringToTop = el => {
		let newLayers = [];

		$stickerLayers.forEach(e => {
			if (e.id === el.getAttribute("data-id")) {
				e.zIndex = $stickerLayers.length + 1;
			} else if (e.zIndex > el.getAttribute("data-z")) {
				e.zIndex = e.zIndex - 1;
			}

			newLayers.push(e);
		});

		stickerLayers.set(newLayers);
	};

	onMount(async () => {
		// interact('.resize-drag').unset()
		interact(".resize-drag").gesturable({
			listeners: {
				start(event) {
					let a = (parseFloat(event.target.getAttribute("data-a")) || 0) - event.angle; // angleScale.angle -= event.angle
					let s = parseFloat(event.target.getAttribute("data-s")) || 1;
					event.target.setAttribute("data-a", a);
					event.target.setAttribute("data-s", s);
				}, // angleScale.angle -= event.angle
				move(event) {
					let a = parseFloat(event.target.getAttribute("data-a")) + event.angle;
					a = a > 360 ? a % 360 : a < -360 ? a % 360 : a;
					let s = parseFloat(event.target.getAttribute("data-s")) * event.scale;
					var currentAngle = a;

					currentAngle = Math.abs(a) < 3
					? 0
					: Math.abs(90 - a) < 3
						? 90
						: Math.abs(-270 - a) < 3
							? 90
							: Math.abs(180 - Math.abs(a)) < 3
								? 180
								: Math.abs(270 - a) < 3
									? 270
									: Math.abs(-90 - a) < 3
										? 270
										: Math.abs(360 - Math.abs(a)) < 3 ? 0 : a;

					var currentScale = s;
					let scaleElement = event.target.firstChild;
					scaleElement.style.webkitTransform = scaleElement.style.transform = "rotate(" + currentAngle + "deg)" + "scale(" + currentScale + ")";

					// uses the dragMoveListener from the draggable demo above
					dragMoveListener(event);
				},
				end(event) {
					let a = (parseFloat(event.target.getAttribute("data-a")) || 0) + event.angle;
					a = a > 360 ? a % 360 : a < -360 ? a % 360 : a;
					let s = (parseFloat(event.target.getAttribute("data-s")) || 1) * event.scale;
					event.target.setAttribute("data-a", a);
					event.target.setAttribute("data-s", s);
				}
			}
		}).draggable({
			onmove: dragMoveListener,
			cursorChecker() {
				// don't set a cursor for drag actions
				return null;
			}
		}).on("down", function (event) {
			bringToTop(event.currentTarget);
		});

		if (window.matchMedia("(hover: hover) and (pointer:fine)").matches) {
			interact(".resize-drag").resizable({
				// resize from all edges and corners
				edges: {
					left: true,
					right: true,
					bottom: true,
					top: true
				},
				modifiers: [
					interact.modifiers.aspectRatio({ ratio: "preserve" }),
					interact.modifiers.restrictSize({ min: { width: 50 } })
				], // max: { width: 500, height: 500 },
				inertia: true
			}).on("resizemove", function (event) {
				if (window.matchMedia("(hover: hover) and (pointer:fine)").matches) {
					var target = event.target,
						x = parseFloat(target.getAttribute("data-x")) || 0,
						y = parseFloat(target.getAttribute("data-y")) || 0;

					// update the element's style
					if (event.rect.width > 50) {
						target.firstChild.style.width = event.rect.width + "px";
						target.firstChild.style.height = event.rect.height + "px";

						// translate when resizing from top or left edges
						x += event.deltaRect.left;

						y += event.deltaRect.top;
						target.style.webkitTransform = target.style.transform = "translate(" + x + "px," + y + "px)";
						target.setAttribute("data-x", x);
						target.setAttribute("data-y", y);
					}

					target.style.maxWidth = "none";
					target.style.maxHeight = "none";
				}
			});
		}
	});

	return [$stickerLayers, $DIM];
}

class Stickers extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Stickers;
export { stickerList, stickerLayers };