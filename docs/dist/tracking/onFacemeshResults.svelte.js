/* src/tracking/onFacemeshResults.svelte generated by Svelte v3.38.3 */
import { SvelteComponent, init, safe_not_equal } from "../../_snowpack/pkg/svelte/internal.js";

import { sendTrackingData } from "./sendTrackingToPeer.svelte.js";
import { p2pConnection } from "../connections/Peer.svelte.js";
import { threshold } from "../utils/helpers.js";
import { videoEl } from "./webcam.svelte.js";
import { drawResults } from "./drawing.svelte.js";
import { options } from "./Holistic.svelte.js";
import { profiles } from "../scene/profiles.svelte.js";
import { user_smooth_face, user_face_position } from "./smooth.svelte.js";
import faceMap, { stabilizeBlink } from "../utils/faceMap/index.js";
import { get } from "../../_snowpack/pkg/svelte/store.js";

let newFace = {
	eye: { l: 1, r: 1 },
	mouth: {
		x: 0,
		y: 0,
		shape: { A: 0, E: 0, I: 0, O: 0, U: 0 }
	},
	head: {
		x: 0,
		y: 0,
		z: 0,
		width: 0.3,
		height: 0.6,
		center: { x: 0.5, y: 0.5, z: 0 }
	},
	brow: 0,
	pupil: { x: 0, y: 0 }
};

let setFace = a => {
	newFace = a;
};

function onFacemeshResults(results) {
	const profile = get(profiles).user;

	if (results.length > 0) {
		drawResults(results[0], "facemesh");
		const lm = results[0].scaledMesh;
		newFace = faceMap.update(lm);

		//don't update pupil if blinking
		if (newFace.eye.r < 0.5 && newFace.eye.l < 0.5) {
			newFace.pupil = get(user_smooth_face).pupil;
		}

		//face mesh model gives back unnormalized values
		//normalize at this step
		newFace.head.width /= videoEl.videoWidth;

		newFace.head.height /= videoEl.videoHeight;
		newFace.head.center.x /= videoEl.videoWidth;
		newFace.head.center.y /= videoEl.videoHeight;
		const oldFace = get(user_smooth_face);

		user_smooth_face.set({
			eye: newFace.eye,
			mouth: newFace.mouth,
			head: {
				x: newFace.head.x,
				y: newFace.head.y,
				z: newFace.head.z
			},
			brow: newFace.brow,
			pupil: {
				x: threshold(oldFace.pupil.x, newFace.pupil.x, 0.1),
				y: threshold(oldFace.pupil.y, newFace.pupil.y, 0.1)
			}
		});

		const oldPos = get(user_face_position);

		user_face_position.set({
			head: {
				x: newFace.head.x,
				y: newFace.head.y,
				z: newFace.head.z
			},
			width: threshold(oldPos.width, newFace.head.width, 0.01),
			height: threshold(oldPos.height, newFace.head.height, 0.01),
			center: {
				x: threshold(oldPos.center.x, newFace.head.center.x, 0.01),
				y: threshold(oldPos.center.y, newFace.head.center.y, 0.01),
				z: newFace.head.center.z
			}
		});

		if (!get(options).face.running) {
			get(options).face.running = true;
			options.set(get(options));
		}

		sendTrackingData();
	}
}

class OnFacemeshResults extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, null, safe_not_equal, {});
	}
}

export default OnFacemeshResults;
export { newFace, setFace, onFacemeshResults };